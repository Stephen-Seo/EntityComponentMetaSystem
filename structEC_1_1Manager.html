<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EntityComponentMetaSystem: EC::Manager&lt; ComponentsList, TagsList, ThreadCount &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EntityComponentMetaSystem
   </div>
   <div id="projectbrief">An implementation of an EntityComponent System with template meta-programming.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>EC</b></li><li class="navelem"><a class="el" href="structEC_1_1Manager.html">Manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structEC_1_1Manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">EC::Manager&lt; ComponentsList, TagsList, ThreadCount &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Manages an EntityComponent system.  
 <a href="structEC_1_1Manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Manager_8hpp_source.html">Manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructFive.html">TPFnDataStructFive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructFive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructFour.html">TPFnDataStructFour</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructFour.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructOne.html">TPFnDataStructOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructOne.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructSeven.html">TPFnDataStructSeven</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructSeven.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructSix.html">TPFnDataStructSix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructSix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructThree.html">TPFnDataStructThree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructThree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructTwo.html">TPFnDataStructTwo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructTwo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager_1_1TPFnDataStructZero.html">TPFnDataStructZero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary struct used internally by <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>.  <a href="structEC_1_1Manager_1_1TPFnDataStructZero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a789046b6bdf685f484b8f07efc14cbb1" id="r_a789046b6bdf685f484b8f07efc14cbb1"><td class="memItemLeft" align="right" valign="top"><a id="a789046b6bdf685f484b8f07efc14cbb1" name="a789046b6bdf685f484b8f07efc14cbb1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Components</b> = ComponentsList</td></tr>
<tr class="separator:a789046b6bdf685f484b8f07efc14cbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3400581e1fcedd33b592d6b2e1a4ff" id="r_aae3400581e1fcedd33b592d6b2e1a4ff"><td class="memItemLeft" align="right" valign="top"><a id="aae3400581e1fcedd33b592d6b2e1a4ff" name="aae3400581e1fcedd33b592d6b2e1a4ff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Tags</b> = TagsList</td></tr>
<tr class="separator:aae3400581e1fcedd33b592d6b2e1a4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a027af1648a2797119ef093576b05c3" id="r_a0a027af1648a2797119ef093576b05c3"><td class="memItemLeft" align="right" valign="top"><a id="a0a027af1648a2797119ef093576b05c3" name="a0a027af1648a2797119ef093576b05c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Combined</b> = EC::Meta::Combine&lt; ComponentsList, TagsList &gt;</td></tr>
<tr class="separator:a0a027af1648a2797119ef093576b05c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56079cda401c05a84c3f9ca91d1ebe3" id="r_af56079cda401c05a84c3f9ca91d1ebe3"><td class="memItemLeft" align="right" valign="top"><a id="af56079cda401c05a84c3f9ca91d1ebe3" name="af56079cda401c05a84c3f9ca91d1ebe3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BitsetType</b> = <a class="el" href="structEC_1_1Bitset.html">EC::Bitset</a>&lt; ComponentsList, TagsList &gt;</td></tr>
<tr class="separator:af56079cda401c05a84c3f9ca91d1ebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd950d2f8e00ced9ca0f1476a0db176" id="r_a9dd950d2f8e00ced9ca0f1476a0db176"><td class="memItemLeft" align="right" valign="top"><a id="a9dd950d2f8e00ced9ca0f1476a0db176" name="a9dd950d2f8e00ced9ca0f1476a0db176"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>ForMatchingFn</b>(std::size_t, <a class="el" href="structEC_1_1Manager.html">Manager</a>&lt; ComponentsList, TagsList &gt; *, void *)</td></tr>
<tr class="separator:a9dd950d2f8e00ced9ca0f1476a0db176"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2593d66e2ea9c61dc6ee518b2dbcaeb" id="r_ad2593d66e2ea9c61dc6ee518b2dbcaeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#ad2593d66e2ea9c61dc6ee518b2dbcaeb">Manager</a> ()</td></tr>
<tr class="memdesc:ad2593d66e2ea9c61dc6ee518b2dbcaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the manager with a default capacity.  <br /></td></tr>
<tr class="separator:ad2593d66e2ea9c61dc6ee518b2dbcaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693034d22c49a40898e5e2d46c06caf7" id="r_a693034d22c49a40898e5e2d46c06caf7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a693034d22c49a40898e5e2d46c06caf7">addEntity</a> ()</td></tr>
<tr class="memdesc:a693034d22c49a40898e5e2d46c06caf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entity to the system, returning the ID of the entity.  <br /></td></tr>
<tr class="separator:a693034d22c49a40898e5e2d46c06caf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda2b4c12cb59bbf0bf133a079596ae7" id="r_acda2b4c12cb59bbf0bf133a079596ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#acda2b4c12cb59bbf0bf133a079596ae7">deleteEntity</a> (std::size_t index)</td></tr>
<tr class="memdesc:acda2b4c12cb59bbf0bf133a079596ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks an entity for deletion.  <br /></td></tr>
<tr class="separator:acda2b4c12cb59bbf0bf133a079596ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ec7f757cbac593a00658d7e1425cdc" id="r_ae8ec7f757cbac593a00658d7e1425cdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#ae8ec7f757cbac593a00658d7e1425cdc">hasEntity</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:ae8ec7f757cbac593a00658d7e1425cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the Entity with the given ID is in the system.  <br /></td></tr>
<tr class="separator:ae8ec7f757cbac593a00658d7e1425cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fbd461cae192d0265e10aa90eeae27" id="r_af6fbd461cae192d0265e10aa90eeae27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#af6fbd461cae192d0265e10aa90eeae27">isAlive</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:af6fbd461cae192d0265e10aa90eeae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the Entity is not marked as deleted.  <br /></td></tr>
<tr class="separator:af6fbd461cae192d0265e10aa90eeae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12829c05964314a465d18be7cd6394ab" id="r_a12829c05964314a465d18be7cd6394ab"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a12829c05964314a465d18be7cd6394ab">getCurrentSize</a> () const</td></tr>
<tr class="memdesc:a12829c05964314a465d18be7cd6394ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size or number of entities in the system.  <br /></td></tr>
<tr class="separator:a12829c05964314a465d18be7cd6394ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6291e99925af1a7137be6acf314f60be" id="r_a6291e99925af1a7137be6acf314f60be"><td class="memItemLeft" align="right" valign="top"><a id="a6291e99925af1a7137be6acf314f60be" name="a6291e99925af1a7137be6acf314f60be"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentCapacity</b> () const</td></tr>
<tr class="separator:a6291e99925af1a7137be6acf314f60be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50ecc7982c372d93ce3c926bb218506" id="r_ae50ecc7982c372d93ce3c926bb218506"><td class="memItemLeft" align="right" valign="top">const EntitiesTupleType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#ae50ecc7982c372d93ce3c926bb218506">getEntityInfo</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:ae50ecc7982c372d93ce3c926bb218506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to an Entity's info.  <br /></td></tr>
<tr class="separator:ae50ecc7982c372d93ce3c926bb218506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975e5d330498c539aad18b50a7a99855" id="r_a975e5d330498c539aad18b50a7a99855"><td class="memTemplParams" colspan="2">template&lt;typename Component &gt; </td></tr>
<tr class="memitem:a975e5d330498c539aad18b50a7a99855"><td class="memTemplItemLeft" align="right" valign="top">Component *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a975e5d330498c539aad18b50a7a99855">getEntityData</a> (const std::size_t &amp;index)</td></tr>
<tr class="memdesc:a975e5d330498c539aad18b50a7a99855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a component belonging to the given Entity.  <br /></td></tr>
<tr class="separator:a975e5d330498c539aad18b50a7a99855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea49c58cba37c54e6d9021c1a7bc210" id="r_acea49c58cba37c54e6d9021c1a7bc210"><td class="memTemplParams" colspan="2">template&lt;typename Component &gt; </td></tr>
<tr class="memitem:acea49c58cba37c54e6d9021c1a7bc210"><td class="memTemplItemLeft" align="right" valign="top">Component *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#acea49c58cba37c54e6d9021c1a7bc210">getEntityComponent</a> (const std::size_t &amp;index)</td></tr>
<tr class="memdesc:acea49c58cba37c54e6d9021c1a7bc210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a component belonging to the given Entity.  <br /></td></tr>
<tr class="separator:acea49c58cba37c54e6d9021c1a7bc210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc940ba41c2fb2c914d52e6fdc32d1" id="r_a6fdc940ba41c2fb2c914d52e6fdc32d1"><td class="memTemplParams" colspan="2">template&lt;typename Component &gt; </td></tr>
<tr class="memitem:a6fdc940ba41c2fb2c914d52e6fdc32d1"><td class="memTemplItemLeft" align="right" valign="top">const Component *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a6fdc940ba41c2fb2c914d52e6fdc32d1">getEntityData</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:a6fdc940ba41c2fb2c914d52e6fdc32d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to a component belonging to the given Entity.  <br /></td></tr>
<tr class="separator:a6fdc940ba41c2fb2c914d52e6fdc32d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22163ca4ec38109d3edcfc44ced0462" id="r_ad22163ca4ec38109d3edcfc44ced0462"><td class="memTemplParams" colspan="2">template&lt;typename Component &gt; </td></tr>
<tr class="memitem:ad22163ca4ec38109d3edcfc44ced0462"><td class="memTemplItemLeft" align="right" valign="top">const Component *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#ad22163ca4ec38109d3edcfc44ced0462">getEntityComponent</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:ad22163ca4ec38109d3edcfc44ced0462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to a component belonging to the given Entity.  <br /></td></tr>
<tr class="separator:ad22163ca4ec38109d3edcfc44ced0462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9183eec38a395202e82796bfc8dffee3" id="r_a9183eec38a395202e82796bfc8dffee3"><td class="memTemplParams" colspan="2">template&lt;typename Component &gt; </td></tr>
<tr class="memitem:a9183eec38a395202e82796bfc8dffee3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a9183eec38a395202e82796bfc8dffee3">hasComponent</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:a9183eec38a395202e82796bfc8dffee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether or not the given Entity has the given Component.  <br /></td></tr>
<tr class="separator:a9183eec38a395202e82796bfc8dffee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd7a1359cd695030efb40f3d21f6722" id="r_a1cd7a1359cd695030efb40f3d21f6722"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a1cd7a1359cd695030efb40f3d21f6722"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a1cd7a1359cd695030efb40f3d21f6722">hasTag</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:a1cd7a1359cd695030efb40f3d21f6722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether or not the given Entity has the given Tag.  <br /></td></tr>
<tr class="separator:a1cd7a1359cd695030efb40f3d21f6722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a3682dfd78c5faeab496887f09753b" id="r_a85a3682dfd78c5faeab496887f09753b"><td class="memTemplParams" colspan="2">template&lt;typename Component , typename... Args&gt; </td></tr>
<tr class="memitem:a85a3682dfd78c5faeab496887f09753b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a85a3682dfd78c5faeab496887f09753b">addComponent</a> (const std::size_t &amp;entityID, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a85a3682dfd78c5faeab496887f09753b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a component to the given Entity.  <br /></td></tr>
<tr class="separator:a85a3682dfd78c5faeab496887f09753b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ea9ef8ccdb0680e36d5cf4c71d418f" id="r_a80ea9ef8ccdb0680e36d5cf4c71d418f"><td class="memTemplParams" colspan="2">template&lt;typename Component &gt; </td></tr>
<tr class="memitem:a80ea9ef8ccdb0680e36d5cf4c71d418f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a80ea9ef8ccdb0680e36d5cf4c71d418f">removeComponent</a> (const std::size_t &amp;entityID)</td></tr>
<tr class="memdesc:a80ea9ef8ccdb0680e36d5cf4c71d418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given Component from the given Entity.  <br /></td></tr>
<tr class="separator:a80ea9ef8ccdb0680e36d5cf4c71d418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544a1d42436416763cc1b8feae9f3f8d" id="r_a544a1d42436416763cc1b8feae9f3f8d"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a544a1d42436416763cc1b8feae9f3f8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a544a1d42436416763cc1b8feae9f3f8d">addTag</a> (const std::size_t &amp;entityID)</td></tr>
<tr class="memdesc:a544a1d42436416763cc1b8feae9f3f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given Tag to the given Entity.  <br /></td></tr>
<tr class="separator:a544a1d42436416763cc1b8feae9f3f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b107a9b7c241c410e59efab1d3aaead" id="r_a9b107a9b7c241c410e59efab1d3aaead"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a9b107a9b7c241c410e59efab1d3aaead"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a9b107a9b7c241c410e59efab1d3aaead">removeTag</a> (const std::size_t &amp;entityID)</td></tr>
<tr class="memdesc:a9b107a9b7c241c410e59efab1d3aaead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given Tag from the given Entity.  <br /></td></tr>
<tr class="separator:a9b107a9b7c241c410e59efab1d3aaead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5c1c6d040f7be1d15ba67d15ae0295" id="r_a6f5c1c6d040f7be1d15ba67d15ae0295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a6f5c1c6d040f7be1d15ba67d15ae0295">reset</a> ()</td></tr>
<tr class="memdesc:a6f5c1c6d040f7be1d15ba67d15ae0295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the <a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">Manager</a>, removing all entities.  <br /></td></tr>
<tr class="separator:a6f5c1c6d040f7be1d15ba67d15ae0295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc333ce7f7e62e4295ea2b460f2067eb" id="r_acc333ce7f7e62e4295ea2b460f2067eb"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename Function &gt; </td></tr>
<tr class="memitem:acc333ce7f7e62e4295ea2b460f2067eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#acc333ce7f7e62e4295ea2b460f2067eb">forMatchingSignature</a> (Function &amp;&amp;function, void *userData=nullptr, const bool useThreadPool=false)</td></tr>
<tr class="memdesc:acc333ce7f7e62e4295ea2b460f2067eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function on all Entities matching the given Signature.  <br /></td></tr>
<tr class="separator:acc333ce7f7e62e4295ea2b460f2067eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4573d2093c4abccbc26e7abff23bf3b" id="r_ae4573d2093c4abccbc26e7abff23bf3b"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename Function &gt; </td></tr>
<tr class="memitem:ae4573d2093c4abccbc26e7abff23bf3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#ae4573d2093c4abccbc26e7abff23bf3b">forMatchingSignaturePtr</a> (Function *function, void *userData=nullptr, const bool useThreadPool=false)</td></tr>
<tr class="memdesc:ae4573d2093c4abccbc26e7abff23bf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function on all Entities matching the given Signature.  <br /></td></tr>
<tr class="separator:ae4573d2093c4abccbc26e7abff23bf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bf8f77b8981a1f4ea91dcb3ef17c9d" id="r_a39bf8f77b8981a1f4ea91dcb3ef17c9d"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename Function &gt; </td></tr>
<tr class="memitem:a39bf8f77b8981a1f4ea91dcb3ef17c9d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a39bf8f77b8981a1f4ea91dcb3ef17c9d">addForMatchingFunction</a> (Function &amp;&amp;function, void *userData=nullptr)</td></tr>
<tr class="memdesc:a39bf8f77b8981a1f4ea91dcb3ef17c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a function in the manager to be called later.  <br /></td></tr>
<tr class="separator:a39bf8f77b8981a1f4ea91dcb3ef17c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c9508105e3fe6cf19d4700d72e776f" id="r_a77c9508105e3fe6cf19d4700d72e776f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a77c9508105e3fe6cf19d4700d72e776f">callForMatchingFunctions</a> (const bool useThreadPool=false)</td></tr>
<tr class="memdesc:a77c9508105e3fe6cf19d4700d72e776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call all stored functions.  <br /></td></tr>
<tr class="separator:a77c9508105e3fe6cf19d4700d72e776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa17502941d9532e509f0c640d86857b" id="r_aaa17502941d9532e509f0c640d86857b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#aaa17502941d9532e509f0c640d86857b">callForMatchingFunction</a> (std::size_t id, const bool useThreadPool=false)</td></tr>
<tr class="memdesc:aaa17502941d9532e509f0c640d86857b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a specific stored function.  <br /></td></tr>
<tr class="separator:aaa17502941d9532e509f0c640d86857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a44665b5b5d4ed99226705a5e7f2da" id="r_a63a44665b5b5d4ed99226705a5e7f2da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a63a44665b5b5d4ed99226705a5e7f2da">clearForMatchingFunctions</a> ()</td></tr>
<tr class="memdesc:a63a44665b5b5d4ed99226705a5e7f2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all stored functions.  <br /></td></tr>
<tr class="separator:a63a44665b5b5d4ed99226705a5e7f2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ce39919c875af47e5c68843df5e9e6" id="r_ae3ce39919c875af47e5c68843df5e9e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#ae3ce39919c875af47e5c68843df5e9e6">removeForMatchingFunction</a> (std::size_t id)</td></tr>
<tr class="memdesc:ae3ce39919c875af47e5c68843df5e9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a function that has the given id.  <br /></td></tr>
<tr class="separator:ae3ce39919c875af47e5c68843df5e9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d98b20e15e0aa91a2b1b51d22f978f" id="r_a57d98b20e15e0aa91a2b1b51d22f978f"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:a57d98b20e15e0aa91a2b1b51d22f978f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a57d98b20e15e0aa91a2b1b51d22f978f">keepSomeMatchingFunctions</a> (List list)</td></tr>
<tr class="memdesc:a57d98b20e15e0aa91a2b1b51d22f978f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all functions that do not have the index specified in argument "list".  <br /></td></tr>
<tr class="separator:a57d98b20e15e0aa91a2b1b51d22f978f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa008ed1d8e1a4e172a24bf3e7e910ce0" id="r_aa008ed1d8e1a4e172a24bf3e7e910ce0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#aa008ed1d8e1a4e172a24bf3e7e910ce0">keepSomeMatchingFunctions</a> (std::initializer_list&lt; std::size_t &gt; list)</td></tr>
<tr class="memdesc:aa008ed1d8e1a4e172a24bf3e7e910ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all functions that do not have the index specified in argument "list".  <br /></td></tr>
<tr class="separator:aa008ed1d8e1a4e172a24bf3e7e910ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7473a3c87f75bd859e8380d479b53fc" id="r_ae7473a3c87f75bd859e8380d479b53fc"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:ae7473a3c87f75bd859e8380d479b53fc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#ae7473a3c87f75bd859e8380d479b53fc">removeSomeMatchingFunctions</a> (List list)</td></tr>
<tr class="memdesc:ae7473a3c87f75bd859e8380d479b53fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all functions that do have the index specified in argument "list".  <br /></td></tr>
<tr class="separator:ae7473a3c87f75bd859e8380d479b53fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17177b506627b97fe2ced68cc6441363" id="r_a17177b506627b97fe2ced68cc6441363"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a17177b506627b97fe2ced68cc6441363">removeSomeMatchingFunctions</a> (std::initializer_list&lt; std::size_t &gt; list)</td></tr>
<tr class="memdesc:a17177b506627b97fe2ced68cc6441363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all functions that do have the index specified in argument "list".  <br /></td></tr>
<tr class="separator:a17177b506627b97fe2ced68cc6441363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffc4a738c498e9fe9b053ab0e15f47c" id="r_a2ffc4a738c498e9fe9b053ab0e15f47c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a2ffc4a738c498e9fe9b053ab0e15f47c">changeForMatchingFunctionContext</a> (std::size_t id, void *userData)</td></tr>
<tr class="memdesc:a2ffc4a738c498e9fe9b053ab0e15f47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the context pointer of a stored function.  <br /></td></tr>
<tr class="separator:a2ffc4a738c498e9fe9b053ab0e15f47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af648b5ef8ed03ae8f189640e1a47acc3" id="r_af648b5ef8ed03ae8f189640e1a47acc3"><td class="memTemplParams" colspan="2">template&lt;typename SigList , typename FTuple &gt; </td></tr>
<tr class="memitem:af648b5ef8ed03ae8f189640e1a47acc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#af648b5ef8ed03ae8f189640e1a47acc3">forMatchingSignatures</a> (FTuple fTuple, void *userData=nullptr, const bool useThreadPool=false)</td></tr>
<tr class="memdesc:af648b5ef8ed03ae8f189640e1a47acc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call multiple functions with mulitple signatures on all living entities.  <br /></td></tr>
<tr class="separator:af648b5ef8ed03ae8f189640e1a47acc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d54b7f0a3fe17309d8c453fdac255b" id="r_a09d54b7f0a3fe17309d8c453fdac255b"><td class="memTemplParams" colspan="2">template&lt;typename SigList , typename FTuple &gt; </td></tr>
<tr class="memitem:a09d54b7f0a3fe17309d8c453fdac255b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a09d54b7f0a3fe17309d8c453fdac255b">forMatchingSignaturesPtr</a> (FTuple fTuple, void *userData=nullptr, const bool useThreadPool=false)</td></tr>
<tr class="memdesc:a09d54b7f0a3fe17309d8c453fdac255b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call multiple functions with mulitple signatures on all living entities.  <br /></td></tr>
<tr class="separator:a09d54b7f0a3fe17309d8c453fdac255b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c6244053d39cc899a3972afad58e36" id="r_a87c6244053d39cc899a3972afad58e36"><td class="memTemplParams" colspan="2">template&lt;typename Signature &gt; </td></tr>
<tr class="memitem:a87c6244053d39cc899a3972afad58e36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a87c6244053d39cc899a3972afad58e36">forMatchingSimple</a> (ForMatchingFn fn, void *userData=nullptr, const bool useThreadPool=false)</td></tr>
<tr class="memdesc:a87c6244053d39cc899a3972afad58e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple version of <a class="el" href="structEC_1_1Manager.html#acc333ce7f7e62e4295ea2b460f2067eb" title="Calls the given function on all Entities matching the given Signature.">forMatchingSignature()</a>  <br /></td></tr>
<tr class="separator:a87c6244053d39cc899a3972afad58e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835ab2b66d85946935d89de4bf6d6ba4" id="r_a835ab2b66d85946935d89de4bf6d6ba4"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a835ab2b66d85946935d89de4bf6d6ba4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEC_1_1Manager.html#a835ab2b66d85946935d89de4bf6d6ba4">forMatchingIterable</a> (Iterable iterable, ForMatchingFn fn, void *userData=nullptr, const bool useThreadPool=false)</td></tr>
<tr class="memdesc:a835ab2b66d85946935d89de4bf6d6ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="structEC_1_1Manager.html#a87c6244053d39cc899a3972afad58e36" title="A simple version of forMatchingSignature()">forMatchingSimple()</a>, but with a collection of Component/Tag indices.  <br /></td></tr>
<tr class="separator:a835ab2b66d85946935d89de4bf6d6ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ComponentsList, typename TagsList, unsigned int ThreadCount = 4&gt;<br />
struct EC::Manager&lt; ComponentsList, TagsList, ThreadCount &gt;</div><p>Manages an EntityComponent system. </p>
<p><a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">EC::Manager</a> must be created with a list of all used Components and all used tags.</p>
<p>Note that all components must have a default constructor.</p>
<p>An optional third template parameter may be given, which is the size of the number of threads in the internal <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>, and should be at least 2. If ThreadCount is 1 or less, then the <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> will not be created and it will never be used, even if the "true" parameter is given for functions that enable its usage.</p>
<p>Note that when calling one of the "forMatching" functions that make use of the internal <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a>, it is allowed to call <a class="el" href="structEC_1_1Manager.html#a693034d22c49a40898e5e2d46c06caf7" title="Adds an entity to the system, returning the ID of the entity.">addEntity()</a> or <a class="el" href="structEC_1_1Manager.html#acda2b4c12cb59bbf0bf133a079596ae7" title="Marks an entity for deletion.">deleteEntity()</a> as the functions cache which entities are alive before running (allowing for <a class="el" href="structEC_1_1Manager.html#a693034d22c49a40898e5e2d46c06caf7" title="Adds an entity to the system, returning the ID of the entity.">addEntity()</a>), and the functions defer deletions during concurrent execution (allowing for <a class="el" href="structEC_1_1Manager.html#acda2b4c12cb59bbf0bf133a079596ae7" title="Marks an entity for deletion.">deleteEntity()</a>).</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structEC_1_1Manager.html">EC::Manager&lt;TypeList&lt;C0, C1, C2&gt;</a>, TypeList&lt;T0, T1&gt;&gt; manager;</div>
<div class="ttc" id="astructEC_1_1Manager_html"><div class="ttname"><a href="structEC_1_1Manager.html">EC::Manager</a></div><div class="ttdoc">Manages an EntityComponent system.</div><div class="ttdef"><b>Definition</b> Manager.hpp:70</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2593d66e2ea9c61dc6ee518b2dbcaeb" name="ad2593d66e2ea9c61dc6ee518b2dbcaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2593d66e2ea9c61dc6ee518b2dbcaeb">&#9670;&#160;</a></span>Manager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::Manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the manager with a default capacity. </p>
<p>The default capacity is set with macro EC_INIT_ENTITIES_SIZE, and will grow by amounts of EC_GROW_SIZE_AMOUNT when needed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85a3682dfd78c5faeab496887f09753b" name="a85a3682dfd78c5faeab496887f09753b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a3682dfd78c5faeab496887f09753b">&#9670;&#160;</a></span>addComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Component , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::addComponent </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>entityID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a component to the given Entity. </p>
<p>Additional parameters given to this function will construct the Component with those parameters.</p>
<p>Note that if the Entity already has the same component, then it will be overwritten by the newly created Component with the given arguments.</p>
<p>If the Entity is not alive or the given Component is not known to the <a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">Manager</a>, then nothing will change.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>C0</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// constructor is compatible as a default constructor</span></div>
<div class="line">    C0(<span class="keywordtype">int</span> a = 0, <span class="keywordtype">char</span> b = <span class="charliteral">&#39;b&#39;</span>) :</div>
<div class="line">    a(a), b(b)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> a;</div>
<div class="line">    <span class="keywordtype">char</span> b;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">manager.addComponent&lt;C0&gt;(entityID, 10, <span class="charliteral">&#39;d&#39;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a693034d22c49a40898e5e2d46c06caf7" name="a693034d22c49a40898e5e2d46c06caf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693034d22c49a40898e5e2d46c06caf7">&#9670;&#160;</a></span>addEntity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::addEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an entity to the system, returning the ID of the entity. </p>
<p>Note: The ID of an entity is guaranteed to not change. </p>

</div>
</div>
<a id="a39bf8f77b8981a1f4ea91dcb3ef17c9d" name="a39bf8f77b8981a1f4ea91dcb3ef17c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bf8f77b8981a1f4ea91dcb3ef17c9d">&#9670;&#160;</a></span>addForMatchingFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Signature , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::addForMatchingFunction </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a function in the manager to be called later. </p>
<p>As an alternative to calling functions directly with <a class="el" href="structEC_1_1Manager.html#acc333ce7f7e62e4295ea2b460f2067eb" title="Calls the given function on all Entities matching the given Signature.">forMatchingSignature()</a>, functions can be stored in the manager to be called later with <a class="el" href="structEC_1_1Manager.html#a77c9508105e3fe6cf19d4700d72e776f" title="Call all stored functions.">callForMatchingFunctions()</a> and callForMatchingFunction, and removed with <a class="el" href="structEC_1_1Manager.html#a63a44665b5b5d4ed99226705a5e7f2da" title="Remove all stored functions.">clearForMatchingFunctions()</a> and <a class="el" href="structEC_1_1Manager.html#ae3ce39919c875af47e5c68843df5e9e6" title="Removes a function that has the given id.">removeForMatchingFunction()</a>.</p>
<p>The syntax for the Function is the same as with <a class="el" href="structEC_1_1Manager.html#acc333ce7f7e62e4295ea2b460f2067eb" title="Calls the given function on all Entities matching the given Signature.">forMatchingSignature()</a>.</p>
<p>Note that functions will be called in the same order they are inserted if called by <a class="el" href="structEC_1_1Manager.html#a77c9508105e3fe6cf19d4700d72e776f" title="Call all stored functions.">callForMatchingFunctions()</a> unless the internal functionIndex counter has wrapped around (is a std::size_t). Calling <a class="el" href="structEC_1_1Manager.html#a63a44665b5b5d4ed99226705a5e7f2da" title="Remove all stored functions.">clearForMatchingFunctions()</a> will reset this counter to zero.</p>
<p>Note that the context pointer provided here (default nullptr) will be provided to the stored function when called.</p>
<p>Example: </p><div class="fragment"><div class="line">manager.addForMatchingFunction&lt;TypeList&lt;C0, C1, T0&gt;&gt;([]</div>
<div class="line">    (std::size_t ID,</div>
<div class="line">    <span class="keywordtype">void</span>* context,</div>
<div class="line">    C0* component0, C1* component1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Lambda function contents here</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// call all stored functions</span></div>
<div class="line">manager.callForMatchingFunctions();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remove all stored functions</span></div>
<div class="line">manager.clearForMatchingFunctions();</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The index of the function, used for deletion with <a class="el" href="structEC_1_1Manager.html#ae3ce39919c875af47e5c68843df5e9e6" title="Removes a function that has the given id.">removeForMatchingFunction()</a> or filtering with <a class="el" href="structEC_1_1Manager.html#a57d98b20e15e0aa91a2b1b51d22f978f" title="Removes all functions that do not have the index specified in argument &quot;list&quot;.">keepSomeMatchingFunctions()</a> or <a class="el" href="structEC_1_1Manager.html#ae7473a3c87f75bd859e8380d479b53fc" title="Removes all functions that do have the index specified in argument &quot;list&quot;.">removeSomeMatchingFunctions()</a>, or calling with <a class="el" href="structEC_1_1Manager.html#aaa17502941d9532e509f0c640d86857b" title="Call a specific stored function.">callForMatchingFunction()</a>. </dd></dl>

</div>
</div>
<a id="a544a1d42436416763cc1b8feae9f3f8d" name="a544a1d42436416763cc1b8feae9f3f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544a1d42436416763cc1b8feae9f3f8d">&#9670;&#160;</a></span>addTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::addTag </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>entityID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given Tag to the given Entity. </p>
<p>Example: </p><div class="fragment"><div class="line">manager.addTag&lt;T0&gt;(entityID);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaa17502941d9532e509f0c640d86857b" name="aaa17502941d9532e509f0c640d86857b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa17502941d9532e509f0c640d86857b">&#9670;&#160;</a></span>callForMatchingFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::callForMatchingFunction </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a specific stored function. </p>
<p>The second parameter can be optionally used to enable the use of the internal <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> to call the stored function in parallel. Using the value false (which is the default) will not use the <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> and run the stored function sequentially on the main thread. Note that multi-threading is based on splitting the task of calling the functions across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up.</p>
<p>Example: </p><div class="fragment"><div class="line">std::size_t <span class="keywordtype">id</span> =</div>
<div class="line">    manager.addForMatchingFunction&lt;TypeList&lt;C0, C1, T0&gt;&gt;(</div>
<div class="line">        [] (std::size_t ID, <span class="keywordtype">void</span>* context, C0* c0, C1* c1) {</div>
<div class="line">    <span class="comment">// Lambda function contents here</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// call the previously added function</span></div>
<div class="line">manager.callForMatchingFunction(<span class="keywordtype">id</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// call the previously added function with ThreadPool enabled</span></div>
<div class="line">manager.callForMatchingFunction(<span class="keywordtype">id</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>False if a function with the given id does not exist. </dd></dl>

</div>
</div>
<a id="a77c9508105e3fe6cf19d4700d72e776f" name="a77c9508105e3fe6cf19d4700d72e776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c9508105e3fe6cf19d4700d72e776f">&#9670;&#160;</a></span>callForMatchingFunctions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::callForMatchingFunctions </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call all stored functions. </p>
<p>The first (and only) parameter can be optionally used to enable the use of the internal <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> to call all stored functions in parallel. Using the value false (which is the default) will not use the <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> and run all stored functions sequentially on the main thread. Note that multi-threading is based on splitting the task of calling the functions across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up.</p>
<p>Example: </p><div class="fragment"><div class="line">manager.addForMatchingFunction&lt;TypeList&lt;C0, C1, T0&gt;&gt;([]</div>
<div class="line">    (std::size_t ID,</div>
<div class="line">    <span class="keywordtype">void</span>* context,</div>
<div class="line">    C0* component0, C1* component1) {</div>
<div class="line">    <span class="comment">// Lambda function contents here</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// call all stored functions</span></div>
<div class="line">manager.callForMatchingFunctions();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// call all stored functions with ThreadPool enabled</span></div>
<div class="line">manager.callForMatchingFunctions(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remove all stored functions</span></div>
<div class="line">manager.clearForMatchingFunctions();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ffc4a738c498e9fe9b053ab0e15f47c" name="a2ffc4a738c498e9fe9b053ab0e15f47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffc4a738c498e9fe9b053ab0e15f47c">&#9670;&#160;</a></span>changeForMatchingFunctionContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::changeForMatchingFunctionContext </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the context pointer of a stored function. </p>
<dl class="section return"><dt>Returns</dt><dd>True if id is valid and context was updated </dd></dl>

</div>
</div>
<a id="a63a44665b5b5d4ed99226705a5e7f2da" name="a63a44665b5b5d4ed99226705a5e7f2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a44665b5b5d4ed99226705a5e7f2da">&#9670;&#160;</a></span>clearForMatchingFunctions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::clearForMatchingFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all stored functions. </p>
<p>Also resets the index counter of stored functions to 0.</p>
<p>Example: </p><div class="fragment"><div class="line">manager.addForMatchingFunction&lt;TypeList&lt;C0, C1, T0&gt;&gt;([]</div>
<div class="line">    (std::size_t ID,</div>
<div class="line">    <span class="keywordtype">void</span>* context,</div>
<div class="line">    C0* component0, C1* component1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Lambda function contents here</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// call all stored functions</span></div>
<div class="line">manager.callForMatchingFunctions();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remove all stored functions</span></div>
<div class="line">manager.clearForMatchingFunctions();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acda2b4c12cb59bbf0bf133a079596ae7" name="acda2b4c12cb59bbf0bf133a079596ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda2b4c12cb59bbf0bf133a079596ae7">&#9670;&#160;</a></span>deleteEntity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::deleteEntity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks an entity for deletion. </p>
<p>A deleted Entity's id is stored to be reclaimed later when addEntity is called. Thus calling addEntity may return an id of a previously deleted Entity. </p>

</div>
</div>
<a id="a835ab2b66d85946935d89de4bf6d6ba4" name="a835ab2b66d85946935d89de4bf6d6ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835ab2b66d85946935d89de4bf6d6ba4">&#9670;&#160;</a></span>forMatchingIterable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::forMatchingIterable </td>
          <td>(</td>
          <td class="paramtype">Iterable&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForMatchingFn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="structEC_1_1Manager.html#a87c6244053d39cc899a3972afad58e36" title="A simple version of forMatchingSignature()">forMatchingSimple()</a>, but with a collection of Component/Tag indices. </p>
<p>This function works like <a class="el" href="structEC_1_1Manager.html#a87c6244053d39cc899a3972afad58e36" title="A simple version of forMatchingSignature()">forMatchingSimple()</a>, but instead of providing template types that filter out non-matching entities, an iterable of indices must be provided which correlate to matching Component/Tag indices. The function given must match the previously defined typedef of type ForMatchingFn.</p>
<p>The fourth parameter can be optionally used to enable the use of the internal <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> to call the function in parallel. Using the value false (which is the default) will not use the <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> and run the function sequentially on all entities on the main thread. Note that multi-threading is based on splitting the task of calling the functions across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up. </p>

</div>
</div>
<a id="acc333ce7f7e62e4295ea2b460f2067eb" name="acc333ce7f7e62e4295ea2b460f2067eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc333ce7f7e62e4295ea2b460f2067eb">&#9670;&#160;</a></span>forMatchingSignature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Signature , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::forMatchingSignature </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the given function on all Entities matching the given Signature. </p>
<p>The function object given to this function must accept std::size_t as its first parameter, void* as its second parameter, and Component pointers for the rest of the parameters. Tags specified in the Signature are only used as filters and will not be given as a parameter to the function.</p>
<p>The second parameter is default nullptr and will be passed to the function call as the second parameter as a means of providing context (useful when the function is not a lambda function).</p>
<p>The third parameter is default false (not multi-threaded). Otherwise, if true, then the thread pool will be used to call the given function in parallel across all entities. Note that multi-threading is based on splitting the task of calling the function across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up.</p>
<p>Example: </p><div class="fragment"><div class="line">Context c; <span class="comment">// some class/struct with data</span></div>
<div class="line">manager.forMatchingSignature&lt;TypeList&lt;C0, C1, T0&gt;&gt;([]</div>
<div class="line">    (std::size_t ID,</div>
<div class="line">    <span class="keywordtype">void</span>* context,</div>
<div class="line">    C0* component0, C1* component1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Lambda function contents here</span></div>
<div class="line">},</div>
<div class="line">&amp;c, <span class="comment">// &quot;Context&quot; object passed to the function</span></div>
<div class="line"><span class="keyword">true</span> <span class="comment">// enable use of internal ThreadPool</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Note, the ID given to the function is not permanent. An entity's ID may change when cleanup() is called. </p>

</div>
</div>
<a id="ae4573d2093c4abccbc26e7abff23bf3b" name="ae4573d2093c4abccbc26e7abff23bf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4573d2093c4abccbc26e7abff23bf3b">&#9670;&#160;</a></span>forMatchingSignaturePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Signature , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::forMatchingSignaturePtr </td>
          <td>(</td>
          <td class="paramtype">Function *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the given function on all Entities matching the given Signature. </p>
<p>The function pointer given to this function must accept std::size_t as its first parameter, void* as its second parameter, and Component pointers for the rest of the parameters. Tags specified in the Signature are only used as filters and will not be given as a parameter to the function.</p>
<p>The second parameter is default nullptr and will be passed to the function call as the second parameter as a means of providing context (useful when the function is not a lambda function).</p>
<p>The third parameter is default false (not multi-threaded). Otherwise, if true, then the thread pool will be used to call the given function in parallel across all entities. Note that multi-threading is based on splitting the task of calling the function across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up.</p>
<p>Example: </p><div class="fragment"><div class="line">Context c; <span class="comment">// some class/struct with data</span></div>
<div class="line"><span class="keyword">auto</span> function = []</div>
<div class="line">    (std::size_t ID,</div>
<div class="line">    <span class="keywordtype">void</span>* context,</div>
<div class="line">    C0* component0, C1* component1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Lambda function contents here</span></div>
<div class="line">};</div>
<div class="line">manager.forMatchingSignaturePtr&lt;TypeList&lt;C0, C1, T0&gt;&gt;(</div>
<div class="line">    &amp;function, <span class="comment">// ptr</span></div>
<div class="line">    &amp;c, <span class="comment">// &quot;Context&quot; object passed to the function</span></div>
<div class="line">    <span class="keyword">true</span> <span class="comment">// enable use of ThreadPool</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Note, the ID given to the function is not permanent. An entity's ID may change when cleanup() is called. </p>

</div>
</div>
<a id="af648b5ef8ed03ae8f189640e1a47acc3" name="af648b5ef8ed03ae8f189640e1a47acc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af648b5ef8ed03ae8f189640e1a47acc3">&#9670;&#160;</a></span>forMatchingSignatures()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename SigList , typename FTuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::forMatchingSignatures </td>
          <td>(</td>
          <td class="paramtype">FTuple&#160;</td>
          <td class="paramname"><em>fTuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call multiple functions with mulitple signatures on all living entities. </p>
<p>(Living entities as in entities that have not been marked for deletion.)</p>
<p>This function requires the first template parameter to be a <a class="el" href="structEC_1_1Meta_1_1TypeList.html">EC::Meta::TypeList</a> of signatures. Note that a signature is a <a class="el" href="structEC_1_1Meta_1_1TypeList.html">EC::Meta::TypeList</a> of components and tags, meaning that SigList is a TypeList of TypeLists.</p>
<p>The second template parameter can be inferred from the function parameter which should be a tuple of functions. The function at any index in the tuple should match with a signature of the same index in the SigList. Behavior is undefined if there are less functions than signatures.</p>
<p>See the Unit Test of this function in src/test/ECTest.cpp for usage examples.</p>
<p>The second parameter (default nullptr) will be provided to every function call as a void* (context).</p>
<p>The third parameter is default false (not multi-threaded). Otherwise, if true, then the thread pool will be used to call the given function in parallel across all entities. Note that multi-threading is based on splitting the task of calling the function across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up.</p>
<p>This function was created for the use case where there are many entities in the system which can cause multiple calls to forMatchingSignature to be slow due to the overhead of iterating through the entire list of entities on each invocation. This function instead iterates through all entities once, storing matching entities in a vector of vectors (for each signature and function pair) and then calling functions with the matching list of entities.</p>
<p>Note that multi-threaded or not, functions will be called in order of signatures. The first function signature pair will be called first, then the second, third, and so on. If this function is called with more than 1 thread specified, then the order of entities called is not guaranteed. Otherwise entities will be called in consecutive order by their ID. </p>

</div>
</div>
<a id="a09d54b7f0a3fe17309d8c453fdac255b" name="a09d54b7f0a3fe17309d8c453fdac255b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d54b7f0a3fe17309d8c453fdac255b">&#9670;&#160;</a></span>forMatchingSignaturesPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename SigList , typename FTuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::forMatchingSignaturesPtr </td>
          <td>(</td>
          <td class="paramtype">FTuple&#160;</td>
          <td class="paramname"><em>fTuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call multiple functions with mulitple signatures on all living entities. </p>
<p>(Living entities as in entities that have not been marked for deletion.)</p>
<p>Note that this function requires the tuple of functions to hold pointers to functions, not just functions.</p>
<p>This function requires the first template parameter to be a <a class="el" href="structEC_1_1Meta_1_1TypeList.html">EC::Meta::TypeList</a> of signatures. Note that a signature is a <a class="el" href="structEC_1_1Meta_1_1TypeList.html">EC::Meta::TypeList</a> of components and tags, meaning that SigList is a TypeList of TypeLists.</p>
<p>The second template parameter can be inferred from the function parameter which should be a tuple of functions. The function at any index in the tuple should match with a signature of the same index in the SigList. Behavior is undefined if there are less functions than signatures.</p>
<p>See the Unit Test of this function in src/test/ECTest.cpp for usage examples.</p>
<p>The second parameter (default nullptr) will be provided to every function call as a void* (context).</p>
<p>The third parameter is default false (not multi-threaded). Otherwise, if true, then the thread pool will be used to call the given function in parallel across all entities. Note that multi-threading is based on splitting the task of calling the function across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up.</p>
<p>This function was created for the use case where there are many entities in the system which can cause multiple calls to forMatchingSignature to be slow due to the overhead of iterating through the entire list of entities on each invocation. This function instead iterates through all entities once, storing matching entities in a vector of vectors (for each signature and function pair) and then calling functions with the matching list of entities.</p>
<p>Note that multi-threaded or not, functions will be called in order of signatures. The first function signature pair will be called first, then the second, third, and so on. If this function is called with more than 1 thread specified, then the order of entities called is not guaranteed. Otherwise entities will be called in consecutive order by their ID. </p>

</div>
</div>
<a id="a87c6244053d39cc899a3972afad58e36" name="a87c6244053d39cc899a3972afad58e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c6244053d39cc899a3972afad58e36">&#9670;&#160;</a></span>forMatchingSimple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Signature &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::forMatchingSimple </td>
          <td>(</td>
          <td class="paramtype">ForMatchingFn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useThreadPool</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple version of <a class="el" href="structEC_1_1Manager.html#acc333ce7f7e62e4295ea2b460f2067eb" title="Calls the given function on all Entities matching the given Signature.">forMatchingSignature()</a> </p>
<p>This function behaves like <a class="el" href="structEC_1_1Manager.html#acc333ce7f7e62e4295ea2b460f2067eb" title="Calls the given function on all Entities matching the given Signature.">forMatchingSignature()</a>, but instead of providing a function with each requested component as a parameter, the function receives a pointer to the manager itself, with which to query component/tag data.</p>
<p>The third parameter can be optionally used to enable the use of the internal <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> to call the function in parallel. Using the value false (which is the default) will not use the <a class="el" href="classEC_1_1ThreadPool.html" title="Implementation of a Thread Pool.">ThreadPool</a> and run the function sequentially on all entities on the main thread. Note that multi-threading is based on splitting the task of calling the functions across sections of entities. Thus if there are only a small amount of entities in the manager, then using multiple threads may not have as great of a speed-up. </p>

</div>
</div>
<a id="a12829c05964314a465d18be7cd6394ab" name="a12829c05964314a465d18be7cd6394ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12829c05964314a465d18be7cd6394ab">&#9670;&#160;</a></span>getCurrentSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::getCurrentSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size or number of entities in the system. </p>
<p>Note this function will only count entities where <a class="el" href="structEC_1_1Manager.html#af6fbd461cae192d0265e10aa90eeae27" title="Checks if the Entity is not marked as deleted.">isAlive()</a> returns true. </p>

</div>
</div>
<a id="acea49c58cba37c54e6d9021c1a7bc210" name="acea49c58cba37c54e6d9021c1a7bc210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea49c58cba37c54e6d9021c1a7bc210">&#9670;&#160;</a></span>getEntityComponent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Component * <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::getEntityComponent </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to a component belonging to the given Entity. </p>
<p>Note that this function is the same as <a class="el" href="structEC_1_1Manager.html#a975e5d330498c539aad18b50a7a99855" title="Returns a pointer to a component belonging to the given Entity.">getEntityData()</a>.</p>
<p>This function will return a pointer to a Component regardless of whether or not the Entity actually owns the Component. If the Entity doesn't own the Component, changes to the Component will not affect any Entity. It is recommended to use <a class="el" href="structEC_1_1Manager.html#a9183eec38a395202e82796bfc8dffee3" title="Checks whether or not the given Entity has the given Component.">hasComponent()</a> to determine if the Entity actually owns that Component.</p>
<p>If the given Component is unknown to the <a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">Manager</a>, then this function will return a nullptr. </p>

</div>
</div>
<a id="ad22163ca4ec38109d3edcfc44ced0462" name="ad22163ca4ec38109d3edcfc44ced0462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22163ca4ec38109d3edcfc44ced0462">&#9670;&#160;</a></span>getEntityComponent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Component * <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::getEntityComponent </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to a component belonging to the given Entity. </p>
<p>Note that this function is the same as <a class="el" href="structEC_1_1Manager.html#a975e5d330498c539aad18b50a7a99855" title="Returns a pointer to a component belonging to the given Entity.">getEntityData()</a> (const).</p>
<p>This function will return a const pointer to a Component regardless of whether or not the Entity actually owns the Component. If the Entity doesn't own the Component, changes to the Component will not affect any Entity. It is recommended to use <a class="el" href="structEC_1_1Manager.html#a9183eec38a395202e82796bfc8dffee3" title="Checks whether or not the given Entity has the given Component.">hasComponent()</a> to determine if the Entity actually owns that Component.</p>
<p>If the given Component is unknown to the <a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">Manager</a>, then this function will return a nullptr. </p>

</div>
</div>
<a id="a975e5d330498c539aad18b50a7a99855" name="a975e5d330498c539aad18b50a7a99855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975e5d330498c539aad18b50a7a99855">&#9670;&#160;</a></span>getEntityData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Component * <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::getEntityData </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to a component belonging to the given Entity. </p>
<p>This function will return a pointer to a Component regardless of whether or not the Entity actually owns the Component. If the Entity doesn't own the Component, changes to the Component will not affect any Entity. It is recommended to use <a class="el" href="structEC_1_1Manager.html#a9183eec38a395202e82796bfc8dffee3" title="Checks whether or not the given Entity has the given Component.">hasComponent()</a> to determine if the Entity actually owns that Component.</p>
<p>If the given Component is unknown to the <a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">Manager</a>, then this function will return a nullptr. </p>

</div>
</div>
<a id="a6fdc940ba41c2fb2c914d52e6fdc32d1" name="a6fdc940ba41c2fb2c914d52e6fdc32d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdc940ba41c2fb2c914d52e6fdc32d1">&#9670;&#160;</a></span>getEntityData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Component * <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::getEntityData </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to a component belonging to the given Entity. </p>
<p>This function will return a const pointer to a Component regardless of whether or not the Entity actually owns the Component. If the Entity doesn't own the Component, changes to the Component will not affect any Entity. It is recommended to use <a class="el" href="structEC_1_1Manager.html#a9183eec38a395202e82796bfc8dffee3" title="Checks whether or not the given Entity has the given Component.">hasComponent()</a> to determine if the Entity actually owns that Component.</p>
<p>If the given Component is unknown to the <a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">Manager</a>, then this function will return a nullptr. </p>

</div>
</div>
<a id="ae50ecc7982c372d93ce3c926bb218506" name="ae50ecc7982c372d93ce3c926bb218506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50ecc7982c372d93ce3c926bb218506">&#9670;&#160;</a></span>getEntityInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EntitiesTupleType &amp; <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::getEntityInfo </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to an Entity's info. </p>
<p>An Entity's info is a std::tuple with a bool, and a bitset.</p>
<p><br  />
 The bool determines if the Entity is alive. <br  />
 The bitset shows what Components and Tags belong to the Entity. </p>

</div>
</div>
<a id="a9183eec38a395202e82796bfc8dffee3" name="a9183eec38a395202e82796bfc8dffee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9183eec38a395202e82796bfc8dffee3">&#9670;&#160;</a></span>hasComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::hasComponent </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether or not the given Entity has the given Component. </p>
<p>Example: </p><div class="fragment"><div class="line">manager.hasComponent&lt;C0&gt;(entityID);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae8ec7f757cbac593a00658d7e1425cdc" name="ae8ec7f757cbac593a00658d7e1425cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ec7f757cbac593a00658d7e1425cdc">&#9670;&#160;</a></span>hasEntity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::hasEntity </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the Entity with the given ID is in the system. </p>
<p>Note that deleted Entities are still considered in the system. Consider using <a class="el" href="structEC_1_1Manager.html#af6fbd461cae192d0265e10aa90eeae27" title="Checks if the Entity is not marked as deleted.">isAlive()</a>. </p>

</div>
</div>
<a id="a1cd7a1359cd695030efb40f3d21f6722" name="a1cd7a1359cd695030efb40f3d21f6722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd7a1359cd695030efb40f3d21f6722">&#9670;&#160;</a></span>hasTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether or not the given Entity has the given Tag. </p>
<p>Example: </p><div class="fragment"><div class="line">manager.hasTag&lt;T0&gt;(entityID);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af6fbd461cae192d0265e10aa90eeae27" name="af6fbd461cae192d0265e10aa90eeae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fbd461cae192d0265e10aa90eeae27">&#9670;&#160;</a></span>isAlive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::isAlive </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the Entity is not marked as deleted. </p>
<p>Note that invalid Entities (Entities where calls to <a class="el" href="structEC_1_1Manager.html#ae8ec7f757cbac593a00658d7e1425cdc" title="Checks if the Entity with the given ID is in the system.">hasEntity()</a> returns false) will return false. </p>

</div>
</div>
<a id="a57d98b20e15e0aa91a2b1b51d22f978f" name="a57d98b20e15e0aa91a2b1b51d22f978f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d98b20e15e0aa91a2b1b51d22f978f">&#9670;&#160;</a></span>keepSomeMatchingFunctions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::keepSomeMatchingFunctions </td>
          <td>(</td>
          <td class="paramtype">List&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all functions that do not have the index specified in argument "list". </p>
<p>The given List must be iterable. This is the only requirement, so a set could also be given.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of functions deleted. </dd></dl>

</div>
</div>
<a id="aa008ed1d8e1a4e172a24bf3e7e910ce0" name="aa008ed1d8e1a4e172a24bf3e7e910ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa008ed1d8e1a4e172a24bf3e7e910ce0">&#9670;&#160;</a></span>keepSomeMatchingFunctions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::keepSomeMatchingFunctions </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all functions that do not have the index specified in argument "list". </p>
<p>This function allows for passing an initializer list.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of functions deleted. </dd></dl>

</div>
</div>
<a id="a80ea9ef8ccdb0680e36d5cf4c71d418f" name="a80ea9ef8ccdb0680e36d5cf4c71d418f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ea9ef8ccdb0680e36d5cf4c71d418f">&#9670;&#160;</a></span>removeComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::removeComponent </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>entityID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given Component from the given Entity. </p>
<p>If the Entity does not have the Component given, nothing will change.</p>
<p>Example: </p><div class="fragment"><div class="line">manager.removeComponent&lt;C0&gt;(entityID);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae3ce39919c875af47e5c68843df5e9e6" name="ae3ce39919c875af47e5c68843df5e9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ce39919c875af47e5c68843df5e9e6">&#9670;&#160;</a></span>removeForMatchingFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::removeForMatchingFunction </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a function that has the given id. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a function was erased. </dd></dl>

</div>
</div>
<a id="ae7473a3c87f75bd859e8380d479b53fc" name="ae7473a3c87f75bd859e8380d479b53fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7473a3c87f75bd859e8380d479b53fc">&#9670;&#160;</a></span>removeSomeMatchingFunctions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::removeSomeMatchingFunctions </td>
          <td>(</td>
          <td class="paramtype">List&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all functions that do have the index specified in argument "list". </p>
<p>The given List must be iterable. This is the only requirement, so a set could also be given.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of functions deleted. </dd></dl>

</div>
</div>
<a id="a17177b506627b97fe2ced68cc6441363" name="a17177b506627b97fe2ced68cc6441363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17177b506627b97fe2ced68cc6441363">&#9670;&#160;</a></span>removeSomeMatchingFunctions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::removeSomeMatchingFunctions </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all functions that do have the index specified in argument "list". </p>
<p>This function allows for passing an initializer list.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of functions deleted. </dd></dl>

</div>
</div>
<a id="a9b107a9b7c241c410e59efab1d3aaead" name="a9b107a9b7c241c410e59efab1d3aaead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b107a9b7c241c410e59efab1d3aaead">&#9670;&#160;</a></span>removeTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::removeTag </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>entityID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given Tag from the given Entity. </p>
<p>If the Entity does not have the Tag given, nothing will change.</p>
<p>Example: </p><div class="fragment"><div class="line">manager.removeTag&lt;T0&gt;(entityID);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6f5c1c6d040f7be1d15ba67d15ae0295" name="a6f5c1c6d040f7be1d15ba67d15ae0295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5c1c6d040f7be1d15ba67d15ae0295">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsList , typename TagsList , unsigned int ThreadCount = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structEC_1_1Manager.html">EC::Manager</a>&lt; ComponentsList, TagsList, ThreadCount &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the <a class="el" href="structEC_1_1Manager.html" title="Manages an EntityComponent system.">Manager</a>, removing all entities. </p>
<p>Some data may persist but will be overwritten when new entities are added. Thus, do not depend on data to persist after a call to <a class="el" href="structEC_1_1Manager.html#a6f5c1c6d040f7be1d15ba67d15ae0295" title="Resets the Manager, removing all entities.">reset()</a>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/EC/<a class="el" href="Manager_8hpp_source.html">Manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
